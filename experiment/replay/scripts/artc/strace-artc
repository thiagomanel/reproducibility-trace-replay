#!/bin/bash
#
# This file is part of artc, the Approximate-Replay Trace Compiler.
#
# Copyright (C) 2012, 2013 Zev Weiss <zev@cs.wisc.edu>
#
# artc is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 2 of the License, or (at your
# option) any later version.
#
# artc is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with artc.  If not, see <http://www.gnu.org/licenses/>.
#

set -u
shopt -s extglob

strace=${STRACE:-strace}

die()
{
	echo >&2 "$*"
	exit 1
}

# $1: call (string)
# $2: return value (string)
emit_setup()
{
	printf -- '0 0.000000 %s = %s <0.000000>\n' "$1" "$2"
}

# $1: path
emit_chdir()
{
	emit_setup "chdir(\"$1\")" "0"
}

# $1: filename
# $2: flags (as a string, e.g. "O_WRONLY|O_APPEND")
# $3: FD number
# $4: position
emit_file_setup()
{
	emit_setup "open(\"$1\", $2)" "$3"
	if [ "$4" != 0 ]; then
		emit_setup "$(printf 'lseek(%d, %ld, SEEK_SET)' "$3" "$4")" "$4"
	fi
}

# $1: FD number
# $2: flags (e.g., "O_WRONLY|O_APPEND")
emit_unknown_file()
{
	emit_setup "socket(PF_FILE, SOCK_STREAM, 0)" "$1"
}

# $1: FD number
# $2: file name (`readlink /proc/fd/$1`, essentially)
# $3: position (decimal)
# $4: flags (octal)
emit_fd_setup()
{
	# echo "emit_fd_setup $@"
	local fdnum="$1" fname="$2" pos="$3" flags="0$4"
	local flagmask="" accmode_set=false

	while read name val; do
		# a hack, but semi-necessary
		if [ "$name" == "O_LARGEFILE" ]; then
			flags="$((flags & ~0100000))"
			continue
		fi

		if [ "$((val))" == 0 ]; then
			continue
		fi

		if [ "$((flags & val))" == "$((val))" ]; then
			flagmask="$flagmask|$name"
			flags="$((flags & ~$val))"
			if [[ "$name" == @(O_WRONLY|O_RDWR) ]]; then
				accmode_set=true
			fi
		fi
	done <<<"$o_flags"

	# another hack
	if ! $accmode_set; then
		flagmask="$flagmask|O_RDONLY"
	fi

	# strip off the leading '|' we should have by now
	flagmask="${flagmask#|}"

	if [ "$((flags))" != 0 ]; then
		printf >&2 "Warning: unknown flags on fd $fdnum: 0%o\n" "$flags"
	fi

	case "$filename" in
	*" (deleted)")
		origname="${filename% (deleted)}"
		emit_file_setup "$origname" "$flagmask|O_CREAT" "$fdnum" "$pos"
		emit_setup "unlink(\"$origname\")" "0"
		;;
	"pipe:["*"]"|"socket:["*"]")
		filetype="${filename%:\[*\]}"
		echo >&2 "Warning: treating $filetype (FD $fdnum) as /dev/zero"
		emit_unknown_file "$fdnum" "$flagmask"
		;;
	/*)
		emit_file_setup "$filename" "$flagmask" "$fdnum" "$pos"
		;;
	*)
		die "file $filename of unsupported type"
		;;
	esac
}

[ $# -lt 1 ] && die "Usage: strace-artc [-o OUTFILE] [-s] [CMD [ARGS...] | -p PID]"

# defaults
outfile="/dev/stderr"
tracepid="0"
sigstop=false
iooutput=''

while getopts :i:o:p:s opt; do
	case "$opt" in
	i) iooutput="$OPTARG" ;;
	o) outfile="$OPTARG" ;;
	p) tracepid="$OPTARG" ;;
	s) sigstop=true ;;
	:) die "'$OPTARG' flag requires argument" ;;
	*) die "unrecognized flag: $OPTARG" ;;
	esac
done

shift $((OPTIND-1))

setuptmp=`mktemp`
stracetmp=`mktemp`

trap "rm -f \"$stracetmp\" \"$setuptmp\"" EXIT

if [ "$tracepid" != "0" ]; then
	[ $# == 0 ] || die "Extraneous arguments with -p PID: $*"

	# We need Linux procfs to get the needed info
	[ "$(uname -s)" == "Linux" ] || die "-p only supported on Linux"

	[ -d "/proc/$tracepid" ] || die "PID $tracepid does not appear to exist"
	[ -r "/proc/$tracepid/fd" ] || die "Can't read from /proc/$tracepid/fd"

	if $sigstop; then
		# Stop the process so we can try to snapshot its FD state
		kill -STOP "$tracepid" || die "Failed to stop PID $tracepid"
	fi

	o_flags="$(gcc -D_GNU_SOURCE -dM -E -x c - <<<$'#include <fcntl.h>' \
		| awk '/^#define[[:space:]]+O_[A-Za-z0-9_]+ [x[:xdigit:]]+/{print $2,$3}')"

	(
		cd "/proc/$tracepid"
		for fd in fd/*; do
			num="${fd#*/}"
			info="fdinfo/$num"
			filename="$(readlink $fd)"
			{ read pos; read flags; } < <(awk '{print $2}' "$info")
			emit_fd_setup "$num" "$filename" "$pos" "$flags"
		done

		emit_chdir "$(readlink cwd)"
	) >> "$setuptmp"

	# so strace invocation below "just works"
	set -- "-p" "$tracepid"
else
	emit_chdir "$(pwd -P)" >> "$setuptmp"
fi

linux_native_aio="io_setup,io_submit,io_getevents,io_cancel,io_destroy"

if [ -n "$iooutput" ]; then
	iostat -k -x 1 > "$iooutput" &
	iopid=$!
	disown $iopid
fi

# -f: follow fork/clone, print pids/tids
# -q: don't print attach/detach messages
# -ttt: high-res absolute timestamps
# -T: print elapsed time for each syscall
# -v: print full structures
# -s 48: only print first 48 bytes of strings (read, write, xattrs...)
# -e signal=none: don't print received signals
# -e trace=desc,file,network: print file, FD, and network-related syscalls only
#      (network so we see things like socket(2) that return FDs)
$strace -f -q -ttt -T -v -s 48 -e signal=none \
	-e trace=desc,file,network,"$linux_native_aio" \
	-o "$stracetmp" "$@" &
tracepid=$!

trap "kill -INT $tracepid" INT TERM
wait $tracepid

if [ -n "$iooutput" ]; then
	kill -TERM $iopid
fi

# an extended regexp matching names of system calls the above strace
# invocation will include, but which we're going to ignore because we
# can't do anything useful with them.
badcalls="setsockopt|shutdown|select|poll|getsockname|execve|ioctl"

{ cat "$setuptmp"; egrep -v " ($badcalls)(\(| resumed>)" "$stracetmp"; } > "$outfile"
