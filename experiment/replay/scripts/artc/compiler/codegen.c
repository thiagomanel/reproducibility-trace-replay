/*
 * This file is part of artc, the Approximate-Replay Trace Compiler.
 *
 * Copyright (C) 2012, 2013 Zev Weiss <zev@cs.wisc.edu>
 *
 * artc is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 2 of the License, or (at your
 * option) any later version.
 *
 * artc is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with artc.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * ARTC C code generation routines.
 */

#include <stdio.h>
#include <inttypes.h>

#include "trace.h"
#include "event.h"
#include "fsmodel.h"
#include "assoc.h"
#include "codegen.h"

#define VERBATIM_FILE(name) \
	extern unsigned char name[]; \
	extern unsigned int name##_len

VERBATIM_FILE(trace_h);
VERBATIM_FILE(fsmodel_h);
VERBATIM_FILE(flags_h);
VERBATIM_FILE(misc_h);
VERBATIM_FILE(system_h);
VERBATIM_FILE(bench_mk);

#define VERBATIM_DESC(basename, filename) { \
	.body = basename, \
	.length = &basename##_len, \
	.target = filename, \
}

/* Pointers because they're extern and we need constant initializers */
static const struct verbatim_file {
	const unsigned char* body;
	const unsigned int* length;
	const char* target;
} verbatim_files[] = {
	VERBATIM_DESC(trace_h, "trace.h"),
	VERBATIM_DESC(fsmodel_h, "fsmodel.h"),
	VERBATIM_DESC(flags_h, "flags.h"),
	VERBATIM_DESC(system_h, "system.h"),
	VERBATIM_DESC(misc_h, "misc.h"),
	/* No bench.mk because it's included as a part of generated Makefile */
};

static void emit_c_header_comment(FILE* output)
{
	fprintf(output,
	        "/*\n"
	        " * This file generated by artc from trace file %s.\n"
	        " * Hand editing not recommended.\n"
	        " */\n"
	        "\n", traceinfo.path);
}

static FILE* new_c_file(const char* path)
{
	FILE* f = xfopen(path, "w");
	emit_c_header_comment(f);
	return f;
}

static int get_remapped_pathidx(int orig)
{
	int remapped;

	if (orig == -1)
		return orig;

	remapped = ii_assoc_lookup(&traceinfo.pathidx_remap, orig);
	assert(remapped != INT_MIN);

	return remapped;
}

static void print_idxlist(FILE* output, const char* name, int* list)
{
	unsigned int i;
	fprintf(output, ".%s = ", name);

	if (!list || list[0] < 0) {
		fprintf(output, "NULL");
		return;
	}

	fprintf(output, "(int[]){ ");
	for (i = 0; list[i] >= 0; i++)
		fprintf(output, "%d, ", get_remapped_pathidx(list[i]));
	fprintf(output, "-1, }");
}

static int max_file_idx = -1;

static void output_basic_tblent(struct event* ev, FILE* output)
{
	int i;
	struct event_dep* dep;
	struct filemd *f;

	fprintf(output, "\t{ .traceline = %d, .serial = %d", ev->traceline,
	        ev->serial);
	fprintf(output, ", .predelays = { .thread = %"PRId64", .fddep = %"PRId64
	        ", .fdorder = %"PRId64", .pathdep = %"PRId64", .fileorder = %"PRId64
	        ", .aiodep = %"PRId64", }", ev->predelays.thread, ev->predelays.fddep,
	        ev->predelays.fdorder, ev->predelays.pathdep, ev->predelays.fileorder,
	        ev->predelays.aiodep);

	fprintf(output, ", .cpu_util = %f", ev->cpu_util);

	fprintf(output, ", .paths = { ");
	print_idxlist(output, "consumed", ev->paths.consumed);
	fprintf(output, ", ");
	print_idxlist(output, "produced", ev->paths.produced);
	fprintf(output, ", ");
	print_idxlist(output, "removed", ev->paths.removed);
	fprintf(output, ", .negdep = "EVPTR_FMT", }", EVDEP_ARGS(ev, ev->paths.negdep));

	fprintf(output, ", .files = { ");

	for (i = 0; ev->files && ev->files[i].pgi; i++) {
		f = &ev->files[i];
		fprintf(output, "{ .idx = %d", f->pgi->id);
		fprintf(output, ", .lastuse = ");
		if (f->lastuse && f->lastuse->thread != SETUP_TID)
			fprintf(output, EVPTR_FMT, EVDEP_ARGS(ev, f->lastuse));
		else
			fprintf(output, "NULL");
		fprintf(output, ", }, ");
		if (f->pgi->id > max_file_idx)
			max_file_idx = f->pgi->id;
	}

	if (i < 2)
		fprintf(output, "{ .idx = -1, .lastuse = NULL, }, ");
	fprintf(output, "}, ");

	fprintf(output, ".type = %s, .attrs.%s = {", event_type_enumname(ev->type),
	        event_type_name(ev->type));

	event_genattrs(ev, output);

	fprintf(output, "}, .ret = { ");
	if (ev->type == EV_MMAP)
		fprintf(output, ".p = (void*)%#"PRIxPTR, (uintptr_t)ev->ret.p);
	else if (ev->type == EV_LSEEK)
		fprintf(output, ".o = (off_t)%jdL", (intmax_t)ev->ret.o);
        else
	        fprintf(output, ".i = %d",
	                event_returns_fd(ev) ? ev->ret.fd.rtidx : ev->ret.i);
	fprintf(output, ", }, .status = RESSTATUS_INIT(RES_FUTURE, -1)");

	fprintf(output, ", .temporal_deps = (struct event_dep[]){ ");
	for (dep = ev->temporal_deps; dep; dep = dep->next) {
		if (dep->event->thread != ev->thread)
			fprintf(output, "{ .event = "EVPTR_FMT", }, ",
			        EVDEP_ARGS(ev, dep->event));
	}
	fprintf(output, "{ .event = NULL, }, }, },\n");
}

/*
 * Gross hack: because io_{submit,getevents} potentially access a list
 * of files, not just one or two, and are generally complicated, we do
 * some event-splitting here at codegen-time.  For each iocb or
 * io_event submitted or returned, we generate a separate event that
 * operates on just that one.
 *
 * This is done by temporarily modifying the event struct's 'files'
 * member and its attributes 'iocbs' (or 'ioevents') member to refer
 * to one of the corresponding list of things at a time, and then
 * calling output_basic_tblent() on it repeatedly (with the
 * attribute-output routines for those just writing out a single
 * iocb/ioevent for each invocation).
 */

static void output_io_submit(struct event* ev, FILE* output)
{
	int i;
	struct artc_iocb* cb;
	struct filemd filetmp[2];
	struct io_submit_attrs* a = &ev->attrs.io_submit;
	struct artc_iocb* orig_cbs = a->iocbs;
	struct filemd* orig_files = ev->files;
	int orig_ret = ev->ret.i;

	filetmp[1] = (struct filemd){ .pgi = NULL, .lastuse = NULL, };

	ev->files = filetmp;
	for (cb = orig_cbs, i = 0; cb; cb = cb->next, i++) {
		a->iocbs = cb;
		assert(orig_files[i].pgi);
		filetmp[0] = orig_files[i];

		/*
		 * We're doing one-at-a-time replay for these, so
		 * we'll expect it to return one.
		 */
		ev->ret.i = (orig_ret >= i) ? 1 : -1;

		output_basic_tblent(ev, output);

		traceinfo.event_type_counts[EV_IO_SUBMIT] += !!i;
	}

	ev->ret.i = orig_ret;
	ev->files = orig_files;
	a->iocbs = orig_cbs;
}

static void output_io_getevents(struct event* ev, FILE* output)
{
	int i;
	struct artc_ioevent* ioe;
	struct filemd filetmp[2];
	struct io_getevents_attrs* a = &ev->attrs.io_getevents;
	struct artc_ioevent* orig_ioes = a->ioevents;
	struct filemd* orig_files = ev->files;
	int orig_ret = ev->ret.i;

	filetmp[1] = (struct filemd){ .pgi = NULL, .lastuse = NULL, };

	ev->files = filetmp;
	for (ioe = orig_ioes, i = 0; ioe; ioe = ioe->next, i++) {
		a->ioevents = ioe;
		assert(orig_files[i].pgi);
		assert(!orig_files[i].lastuse);
		filetmp[0] = orig_files[i];

		/*
		 * For one-at-a-time replay we expect it to return one
		 * (assuming the original succeeded).
		 */
		ev->ret.i = (orig_ret > 0) ? 1 : 0;

		output_basic_tblent(ev, output);

		traceinfo.event_type_counts[EV_IO_GETEVENTS] += !!i;
	}

	ev->ret.i = orig_ret;
	ev->files = orig_files;
	a->ioevents = orig_ioes;
}

static void output_tblent(struct event* ev, FILE* output)
{
	if (ev->type == EV_IO_SUBMIT)
		output_io_submit(ev, output);
	else if (ev->type == EV_IO_GETEVENTS)
		output_io_getevents(ev, output);
	else
		output_basic_tblent(ev, output);
}

/*
 * Output at most THREAD_FILE_MAX_EVENTS events from the list starting at
 * 'first_event', returning a pointer to the next event not written out, or
 * NULL if the end of the list was reached.
 */
static struct event* output_thread_trace(FILE* output, struct event* first_event)
{
	struct event* e;
	int count;

	for (e = first_event, count = 0; e && count < THREAD_FILE_MAX_EVENTS; e = e->next, count++)
		output_tblent(e, output);

	return e;
}

static void output_pseudoevent_start(FILE* output)
{
	int i;

	fprintf(output, "\t{ .traceline = -1, .serial = -1, .predelays = ");
	fprintf(output, "DEPDELAY_STATICINIT, .cpu_util = 0.0, . paths = {");
	fprintf(output, " .consumed = NULL, .produced = NULL, .removed = NULL,");
	fprintf(output, " .negdep = NULL, }, .files = { ");
	for (i = 0; i < 2; i++)
		fprintf(output, "{ .idx = -1, .lastuse = NULL, }, ");
	fprintf(output, "}, ");
}

/*
 * FIXME: doing thread chunking by inserting the EV__THREADCONT pseudo-events
 * earlier in the compiler might be nicer.
 */
static void output_thread_continuation(FILE* output, const char* nextchunk)
{
	output_pseudoevent_start(output);
	fprintf(output, ".type = EV__THREADCONT, .attrs.threadcont = {");
	fprintf(output, " .next = %s, }, .ret = { .i = 0, }, },\n", nextchunk);
}

static void output_thread_exit(FILE* output)
{
	output_pseudoevent_start(output);
	fprintf(output, ".type = EV__THREADEXIT, },\n");
}

static struct event* output_thread_chunk_file(FILE* output, struct threadtrace* t,
                                              struct event* first_event, const char* name,
                                              int chunknum)
{
	struct event* next;
	char nextchunk_name[128];

	fprintf(output,
	        "#include \"system.h\"\n"
	        "#ifdef LINUX\n"
	        "#define _GNU_SOURCE\n"
	        "#endif\n"
	        "\n"
	        "#include <unistd.h>\n"
	        "#include <fcntl.h>\n"
	        "#include <sys/stat.h>\n"
	        "#include <sys/types.h>\n"
	        "#include <sys/mman.h>\n"
	        "\n"
	        "#include \"flags.h\"\n"
	        "#include \"trace.h\"\n"
	        "#include \"threads.h\"\n\n");

	fprintf(output, "extern struct aio_info aiocbs[];\n");

	/*
	 * IO buffer needs to be page-aligned in case we need to do O_DIRECT
	 * I/O to/from it.
	 */
	fprintf(output, "\n%schar %s_iobuf[%zd] __attribute__((aligned(4096)));\n",
	        chunknum ? "extern " : "", name, t->maxbuf);

	fprintf(output, "\nstruct event %s_chunk%d_trace[] = {\n", name, chunknum);

	next = output_thread_trace(output, first_event);

	if (next) {
		assert(t->length / THREAD_FILE_MAX_EVENTS > chunknum);
		snprintf(nextchunk_name, sizeof(nextchunk_name), "%s_chunk%d_trace", name, chunknum+1);
		output_thread_continuation(output, nextchunk_name);
	} else {
		assert(t->length / THREAD_FILE_MAX_EVENTS == chunknum);
		output_thread_exit(output);
	}

	fprintf(output, "};\n");

	if (!chunknum) {
	        fprintf(output, "\nstruct thread %s = {\n", name);
	        fprintf(output, "\t.evtable = %s_chunk%d_trace,\n", name, chunknum);
	        fprintf(output, "\t.tid = %d,\n", t->id);
	        fprintf(output, "};\n");
	}

	return next;
}

static void output_thread_files_visitor(int tid, struct threadtrace* t, void* arg)
{
	char namebuf[128], pathbuf[128];
	int chunknum;
	struct event* evptr;
	FILE* output;

	if (!t->length)
		return;

	snprintf(namebuf, sizeof(namebuf), "thread%d", t->id);

	for (evptr = t->evlist.head, chunknum = 0; evptr; chunknum++) {
		if (chunknum)
			snprintf(pathbuf, sizeof(pathbuf), "thread%d_cont%d.c", t->id, chunknum);
		else
			snprintf(pathbuf, sizeof(pathbuf), "thread%d.c", t->id);

		output = new_c_file(pathbuf);
		evptr = output_thread_chunk_file(output, t, evptr, namebuf, chunknum);
		fclose(output);
	}
}

static void output_thread_files(void)
{
	it_assoc_visit(&traceinfo.threadassoc, output_thread_files_visitor, NULL);
}

static void output_setup_file(void)
{
	FILE* output;

	if (!traceinfo.setupthread.evlist.head)
		return;

	/*
	 * If the setupthread is too long for one file...something's probably
	 * gone horribly wrong.
	 */
	if (traceinfo.setupthread.length > THREAD_FILE_MAX_EVENTS) {
		fprintf(stderr, "setupthread > THREAD_FILE_MAX_EVENTS!\n");
		abort();
	}

	output = new_c_file("setup.c");
	output_thread_chunk_file(output, &traceinfo.setupthread,
	                         traceinfo.setupthread.evlist.head,"setup", 0);
	fclose(output);
}

static void output_thread_trace_declaration(int tid, struct threadtrace* t, void* arg)
{
	int i;
	FILE* output = arg;

	if (t->length)
		fprintf(output, "extern struct thread thread%d;\n", t->id);

	/*
	 * Expose its component chunks for event (non-resource) dependencies
	 * (for temporal ordering).
	 */
	for (i = 0; i < t->length; i += THREAD_FILE_MAX_EVENTS)
		fprintf(output, "extern struct event thread%d_chunk%d_trace[];\n",
		        t->id, i/THREAD_FILE_MAX_EVENTS);
}

struct ots_args {
	FILE* output;
	int count;
};

static void output_thread_struct(int tid, struct threadtrace* t, void* varg)
{
	struct ots_args* args = varg;

	if (t->length) {
		fprintf(args->output, "\t&thread%d,\n", t->id);
		args->count++;
	}
}

/* Returns the number of threads in the generated 'threads' array. */
static unsigned int write_threads_files(void)
{
	FILE* output;
	struct ots_args ots;

	output = new_c_file("threads.h");

	fprintf(output, "#ifndef THREADS_H\n");
	fprintf(output, "#define THREADS_H\n\n");
	fprintf(output, "#include \"trace.h\"\n\n");
	fprintf(output, "#define thread0_chunk0_trace ((struct event*)NULL)\n\n");
	it_assoc_visit(&traceinfo.threadassoc, output_thread_trace_declaration, output);
	if (traceinfo.setupthread.evlist.head)
		fprintf(output, "extern struct thread setup;\n");
	fprintf(output, "\nextern struct thread* threads[];\n");
	fprintf(output, "\n#endif /* THREADS_H */\n");

	fclose(output);

	output = new_c_file("threads.c");

	fprintf(output, "#include \"trace.h\"\n");
	fprintf(output, "#include \"threads.h\"\n\n");

	ots.output = output;
	ots.count = 0;

	fprintf(output, "struct thread* threads[] = {\n");
	it_assoc_visit(&traceinfo.threadassoc, output_thread_struct, &ots);
	fprintf(output, "};\n");

	fclose(output);

	return ots.count;
}

static void write_verbatim_file(const struct verbatim_file* vf)
{
	FILE* f;

	f = xfopen(vf->target, "w");

	fwrite(vf->body, *vf->length, 1, f);
	fclose(f);
}

static void write_verbatim_files(void)
{
	int i;

	for (i = 0; i < ARR_SIZE(verbatim_files); i++)
		write_verbatim_file(&verbatim_files[i]);
}

static void print_initpath_entry(const char* path, struct pathent* pe,
                                 struct pathgen* pg, void* arg)
{
	int remapped_idx;
	FILE* f = arg;

	if (pathent_frominit(pe)
	    && (all_init_files || pathent_used(pe))
	    && pg == path_getgen(pe, 0)) {
		remapped_idx = ii_assoc_lookup(&traceinfo.pathidx_remap, pg->id);
		assert(remapped_idx != INT_MIN);
		fprintf(f, "%s# %u\n", relpath_from_abs(path), remapped_idx);
	}
}

static void write_initpaths_file(void)
{
	FILE* f;

	f = xfopen("initpaths.gperf.new", "w");

	fprintf(f, "%%{\n#include \"fsmodel.h\"\n%%}\n\n");
	fprintf(f, "%%define slot-name path\n"
	        "%%language=ANSI-C\n"
	        "%%struct-type\n"
	        "%%delimiters=\"#\"\n"
	        "%%global-table\n"
	        "%%includes\n"
	        "%%null-strings\n"
	        "%%define lookup-function-name get_initpath\n"
	        "%%define word-array-name initpaths\n"
	        "\n"
	        "struct initpath;\n"
	        "%%%%\n");

	fsm_visit(traceinfo.fsm, print_initpath_entry, f);

	fprintf(f, "%%%%\n\n"
	        "void visit_initpaths(void (*fn)(const struct initpath* ip, "
	        "void* arg), void* arg)\n"
	        "{\n"
	        "\tint i;\n"
	        "\tfor (i = 0; i < sizeof(initpaths)/sizeof(initpaths[0]); i++) {\n"
	        "\t\tif (initpaths[i].path)\n"
	        "\t\t\tfn(&initpaths[i], arg);\n"
	        "\t}\n"
	        "}\n");
	fclose(f);

	/* Quick hack to avoid a slow code-regeneration if not necessary */
	if (system("cmp -s initpaths.gperf initpaths.gperf.new")) {
		if (rename("initpaths.gperf.new", "initpaths.gperf")) {
			perror("rename");
			exit(1);
		}
	} else {
		if (unlink("initpaths.gperf.new")) {
			perror("unlink");
			exit(1);
		}
	}
}

static const char* filetype_strs[] = {
	[FT_FILE] = "FT_FILE",
	[FT_DIR] = "FT_DIR",
	[FT_SYMLINK] = "FT_SYMLINK",
	[FT_HOSTLINK] = "FT_SYMLINK",
};

struct ppe_arg {
	FILE* out;
	unsigned int count;
};

static unsigned num_output_paths = 0;

static void print_pathgens_entry(const char* path, struct pathent* pe,
                                 struct pathgen* pg, void* arg)
{
	int i;
	int remapped_idx;
	struct ppe_arg* pa = arg;
	FILE* f = pa->out;

	if (!all_init_files && !pathent_used(pe)) {
		assert(pe->gencnt == 1);
		return;
	}

	remapped_idx = num_output_paths++;
	ii_assoc_insert(&traceinfo.pathidx_remap, pg->id, remapped_idx);

	fprintf(f, "\t[%d] = { .status = RESSTATUS_INIT(RES_FUTURE, %d), ",
	        remapped_idx, pg->usecnt);

	fprintf(f, ".info = { .type = %s, ", filetype_strs[pg->info->type]);

	switch (pg->info->type) {
	case FT_FILE:
		if (pathent_frominit(pe) && pg == path_getgen(pe, 0))
			fprintf(f, "{ .size = %jd, }, ", (intmax_t)pg->info->size);
		break;

	case FT_HOSTLINK:
		if (pathent_frominit(pe) && pg == path_getgen(pe, 0))
			fprintf(f, "{ .target = \"%s\", }, ", pg->info->target);
		break;

	case FT_SYMLINK:
		if (pathent_frominit(pe) && pg == path_getgen(pe, 0)) {
			fprintf(f, "{ .target = \"");
			/*
			 * If the target is an absolute path, prepend '..'
			 * entries to make it relative.
			 */
			if (pg->info->target[0] == '/') {
				for (i = 1; path[i]; i++) {
					if (path[i] == '/')
						fprintf(f, "../");
				}
			}
			fprintf(f, "%s\",} , ", relpath_from_abs(pg->info->target));
		}
		break;

	case FT_DIR:
		break;

	default:
		abort();
	}

	pa->count++;

	/* include the path in a comment for debugging convenience */
	fprintf(f, "}, }, /* %s */\n", *path ? path : "/");
}

/* Returns the number of pathgens in the generated array. */
static unsigned int write_paths_file(void)
{
	struct ppe_arg pa;
	FILE* f = new_c_file("paths.c");

	fprintf(f, "#include \"fsmodel.h\"\n\n");

	fprintf(f, "struct pathgen pathgens[] = {\n");

	pa.count = 0;
	pa.out = f;
	fsm_visit(traceinfo.fsm, print_pathgens_entry, &pa);

	fprintf(f, "};\n");
	fclose(f);

	return pa.count;
}

static void write_summary(unsigned int num_pathgens, unsigned int num_files,
                          const struct threadtrace* firstthread, unsigned int num_threads)
{
	FILE* f = new_c_file("bench.c");

	fprintf(f, "#include \"trace.h\"\n");
	fprintf(f, "#include \"fsmodel.h\"\n\n");
	fprintf(f, "#include \"threads.h\"\n\n");

	fprintf(f, "extern struct fd_info fds[];\n"
	        "extern const int mystery_fds[];\n"
	        "extern struct aio_info* aiocbs[];\n"
	        "#ifdef LINUX\n"
	        "extern io_context_t aioctxs[];\n"
	        "extern int mystery_aioctxs[];\n"
	        "#endif\n"
	        "extern struct pathgen pathgens[];\n"
	        "extern struct resstatus files[];\n"
	        "extern void visit_initpaths(void (*fn)(const struct initpath* ip, "
	        "void* arg), void* arg);\n"
	        "extern struct initpath* get_initpath(register const char* str, "
	        "register unsigned int len);\n\n"
		"extern const char version_string[];\n\n");

	fprintf(f, "struct benchmark __attribute__((visibility(\"default\"))) "
	        "benchmark = {\n");

	fprintf(f, "\t.fds = fds,\n"
	        "\t.num_fds = %u,\n", traceinfo.num_fds);
	fprintf(f, "\t.mystery_fds = mystery_fds,\n"
	        "\t.num_mystery_fds = %u,\n", traceinfo.num_mystery_fds);
	fprintf(f, "\t.aiocbs = aiocbs,\n"
	        "\t.num_aiocbs = %u,\n", traceinfo.num_aio_infos);
	fprintf(f, "#ifdef LINUX\n"
	        "\t.aioctxs = aioctxs,\n"
	        "\t.num_aioctxs = %u,\n"
	        "\t.mystery_aioctxs = mystery_aioctxs,\n"
	        "\t.num_mystery_aioctxs = %u,\n"
	        "#endif\n", traceinfo.num_aio_ctxs, traceinfo.num_mystery_aioctxs);
	fprintf(f, "\t.pathgens = pathgens,\n"
	        "\t.num_pathgens = %u,\n", num_pathgens);
	fprintf(f, "\t.files = files,\n"
	        "\t.num_files = %u,\n", num_files);
	fprintf(f, "\t.threads = threads,\n"
	        "\t.num_threads = %u,\n"
	        "\t.first_thread = &thread%d,\n", num_threads, firstthread->id);
	fprintf(f, "\t.setup = %s,\n",
	        traceinfo.setupthread.evlist.head ? "&setup" : "NULL");
	fprintf(f, "\t.cpucount = %lu,\n", traceinfo.cpucount);

	fprintf(f, "\t.version_string = version_string,\n");
	fprintf(f, "\t.visit_initpaths = visit_initpaths,\n");
	fprintf(f, "\t.get_initpath = get_initpath,\n");

	fprintf(f, "};\n");

	fclose(f);
}

struct aiocbfile {
	/* The file we're writing to */
	FILE* file;

	/* How many aio_infos we've written to it */
	unsigned int count;

	/* The largest I/O buffer needed by calls written out so far */
	size_t maxbuf;
};

static struct aiocbfile* aiocbfiles = NULL;
static unsigned int num_aiocbfiles = 0;

static void finish_aiocbfile(struct aiocbfile* af)
{
	fprintf(af->file, "};\n");
	/* Align for potential O_DIRECT I/O */
	fprintf(af->file, "\nstatic char aio_iobuf[%zu] __attribute__((aligned(4096)));\n",
	        af->maxbuf);
	fclose(af->file);
	af->file = NULL;
}

static void write_aio_info(int aiocbnum, size_t (*details)(FILE*, const void*), const void* arg)
{
	char pathbuf[128];
	struct aiocbfile* af;
	size_t nbytes;
	int filenum = aiocbnum / AIOCBS_PER_CHUNK;
	int idx = aiocbnum % AIOCBS_PER_CHUNK;

	if (filenum >= num_aiocbfiles) {
		aiocbfiles = xrealloc(aiocbfiles, (filenum+1)*sizeof(*aiocbfiles));
		memset(aiocbfiles + num_aiocbfiles, 0,
		       (filenum + 1 - num_aiocbfiles) * sizeof(*aiocbfiles));
		num_aiocbfiles = filenum + 1;
	}

	af = &aiocbfiles[filenum];

	if (!af->file) {
		assert(!af->count);
		snprintf(pathbuf, sizeof(pathbuf), "aiocbs_%d.c", filenum);
		af->file = new_c_file(pathbuf);

		fprintf(af->file, "#include <pthread.h>\n\n");
		fprintf(af->file, "#include \"trace.h\"\n\n");
		fprintf(af->file, "static char aio_iobuf[];\n");
		fprintf(af->file, "struct aio_info aiocbs_%d[] = {\n", filenum);
	}

	assert(af->count < AIOCBS_PER_CHUNK);

	fprintf(af-> file, "\t[%d] = { .status = RESSTATUS_INIT(RES_FUTURE, -1), ",
	        idx);
	nbytes = details(af->file, arg);
	fprintf(af->file, ", },\n");

	af->count += 1;

	if (nbytes > af->maxbuf)
		af->maxbuf = nbytes;

	if (af->count == AIOCBS_PER_CHUNK)
		finish_aiocbfile(af);
}

static size_t poscb_details(FILE* out, const void* arg)
{
	const struct aio_read_attrs* a = arg;

	fprintf(out, ".u.gencb = { ");
	fprintf(out, ".op = GA_PREAD, ");
	fprintf(out, ".fd = -1, ");
	fprintf(out, ".buf = aio_iobuf, ");
	fprintf(out, ".len = %zd, ", a->nbytes);
	fprintf(out, ".offset = %jd, ", (intmax_t)a->offset);
	fprintf(out, "}");

	return a->nbytes;
}

void output_posix_aiocb(const struct event* e)
{
	const struct aio_read_attrs* a;

	assert(e->type == EV_AIO_READ);
	a = &e->attrs.aio_read;

	write_aio_info(a->aiocbnum, poscb_details, a);
}

static size_t lincb_details(FILE* out, const void* arg)
{
	const struct artc_iocb* cb = arg;

	fprintf(out, ".u.gencb = { ");
	fprintf(out, ".op = GA_%s, ",
	        cb->type == AT_PREAD ? "PREAD"
	        : cb->type == AT_PWRITE ? "PWRITE"
	        : (abort(), ""));
	fprintf(out, ".fd = -1, ");
	fprintf(out, ".buf = aio_iobuf, ");
	fprintf(out, ".len = %zd, ", cb->nbytes);
	fprintf(out, ".offset = %jd, ", (intmax_t)cb->offset);
	fprintf(out, "}");

	return cb->nbytes;
}

void output_linux_aiocb(const struct artc_iocb* cb)
{
	write_aio_info(cb->aiocbnum, lincb_details, cb);
}

static void output_mystery_aioctx(int key, int val, void* arg)
{
	fprintf(arg, "%d, ", key);
}

static void end_aiocbs(void)
{
	int i;
	FILE* f;

	for (i = 0; i < num_aiocbfiles; i++) {
		if (aiocbfiles[i].file)
			finish_aiocbfile(&aiocbfiles[i]);
	}

	xfree(aiocbfiles);

	f = new_c_file("aiocbs.c");
	fprintf(f, "#include \"trace.h\"\n\n");
	for (i = 0; i < num_aiocbfiles; i++)
		fprintf(f, "extern struct aio_info aiocbs_%d[];\n", i);
	fprintf(f, "\nstruct aio_info* aiocbs[] = {\n");
	for (i = 0; i < num_aiocbfiles; i++)
		fprintf(f, "\taiocbs_%d,\n", i);
	fprintf(f, "};\n");

	fprintf(f, "\n#ifdef LINUX\n");
	fprintf(f, "io_context_t aioctxs[%d];\n", traceinfo.num_aio_ctxs);
	fprintf(f, "int mystery_aioctxs[%u] = { ", traceinfo.num_mystery_aioctxs);
	ii_assoc_visit(&traceinfo.mystery_aioctxs, output_mystery_aioctx, f);
	fprintf(f, "};\n");
	fprintf(f, "#endif\n");

	fclose(f);
}

static void output_thread_dot_os(int tid, struct threadtrace* t, void* arg)
{
	int i;
	FILE* output = arg;

	if (t->length) {
		fprintf(output, " thread%d.o", t->id);
		for (i = 1; i * THREAD_FILE_MAX_EVENTS < t->length; i++)
			fprintf(output, " thread%d_cont%d.o", t->id, i);
	}
}

static void write_makefile(void)
{
	int i;
	FILE* output;

	output = xfopen("Makefile", "w");

	fprintf(output,
	        "# This file generated by artc from %s.\n"
	        "# Hand editing not recommended.\n", traceinfo.path);

	fprintf(output, "\ndefault: benchdefault\n");

	fwrite(bench_mk, bench_mk_len, 1, output);

	fprintf(output, "\nversion.c: bench.dbg.o\n");
	fprintf(output, "\t@echo \"const char version_string[] = \\\""
	        "$(call getversion,$<)\\\";\" > $@\n");

	fprintf(output, "\nbench.$(DSO_EXT): threads.o aiocbs.o fds.o initpaths.gp.o "
	        "paths.o bench.o version.o");
	it_assoc_visit(&traceinfo.threadassoc, output_thread_dot_os, output);

	if (traceinfo.setupthread.evlist.head)
		fprintf(output, " setup.o");

	for (i = 0; i < num_aiocbfiles; i++)
		fprintf(output, " aiocbs_%d.o", i);

	fprintf(output, "\n\t$(BENCH_CC) $(DSOFLAGS) -o $@ "
	        "$(BENCH_CFLAGS) $^\n");

	fclose(output);
}

static void print_mystery_fdidx(int fdidx, struct event* ev, void* arg)
{
	FILE* f = arg;
	fprintf(f, " %d,", fdidx);
}

static void write_fdfile(void)
{
	unsigned int i;
	FILE* f;
	struct pginfo* pgi;
	int file_idx;

	f = new_c_file("fds.c");

	fprintf(f, "#include <pthread.h>\n\n");
	fprintf(f, "#include \"trace.h\"\n\n");
	fprintf(f, "struct fd_info fds[%u] = {\n", traceinfo.num_fds);

	for (i = 0; i < traceinfo.num_fds; i++) {
		pgi = ip_assoc_lookup(&traceinfo.fd_pgi_map, i);
		assert(pgi);
		file_idx = pgi == NONFILE_PGINFO ? -1 : pgi->id;
		fprintf(f, "\t[%u] = { .status = RESSTATUS_INIT(RES_FUTURE, %d), "
		        ".fd = -1, .file_idx = %d, },\n", i, traceinfo.fdidx_evcounts[i],
		        file_idx);
	}

	fprintf(f, "};\n");

	fprintf(f, "\n/* Initialized at runtime */\n");
	fprintf(f, "struct resstatus files[%d];\n", max_file_idx + 1);

	fprintf(f, "\nconst int mystery_fds[] = {");
	ie_assoc_visit(&traceinfo.mystery_fds, print_mystery_fdidx, f);
	fprintf(f, " };\n");

	fclose(f);
}

void generate_code(const struct threadtrace* firstthread)
{
	unsigned int num_pathgens, num_threads;

	end_aiocbs();

	num_pathgens = write_paths_file();

	output_thread_files();
	num_threads = write_threads_files();

	write_fdfile();

	output_setup_file();
	write_initpaths_file();

	write_verbatim_files();

	write_makefile();

	write_summary(num_pathgens, max_file_idx+1, firstthread, num_threads);
}
