% artc(1) ARTC
% Zev Weiss <zev@cs.wisc.edu>
% September 2013

# NAME

artc - an Approximate-Replay Trace Compiler

# SYNOPSIS

artc [FLAGS] *TRACEFILE* *INITFILE* *OUTDIR*

artc [FLAGS] -A *INFO* *TRACEFILE* *INITFILE*

# DESCRIPTION

artc compiles system-call traces into replayable benchmarks.  It
specializes in extracting ordering dependencies from multithreaded
traces, allowing replay to proceed in a nondeterministic fashion, with
calls being made in potentially very different orders than shown in
the trace, while preserving execution correctness.

Its output is in the form of a directory containing a number of C
source code files (*.c, *.h), a gperf(1) file, and a Makefile.

After generating the output directory, running \`make -C *OUTDIR*'
compiles the generated code into its final form, a shared library to
be loaded and run by `artrun`(1).

# OPTIONS

-A *INFO*, \--extract=*INFO*

  : Instead of generating the usual directory of output, instead just
    print some information to stdout.  Exactly what information is
    determined by *INFO*, which is a comma-separated list of any of
    the following -- note though that all of these output go to the
    same stream (stdout), so while `artc` does support using multiple
    INFO items at once, actually specifying more than one may not be
    what you want:

> * *depgraph*: a GraphViz DOT language directed graph of (some of)
>   the ordering dependencies extracted by artc.

> * *thread_logs*: one (probably very long) line for each thread in
>   the trace, with one entry of the form *TYPE*:*START*:*LENGTH* for
>   each system call, where *TYPE* is the kind of system call
>   (e.g. `open`(2)), *START* is the time (in nanoseconds since the
>   beginning of the trace) at which the call was issued, and *LENGTH*
>   is the duration of time (also in nanoseconds) for which the call
>   was outstanding (*START* \+ *LENGTH* is thus the time at which the
>   call returned).  This is the same format used in the output of
>   `artrun`(1), so the same post-processing can be applied to both.

> * *summary*: a brief summary of basic information about the trace
>   (number of threads, number of file descriptors, elapsed time,
>   etc.)


-a, \--all-initfiles

  : By default, `artc` elides from its output any paths present in
    *INITFILE* that are not referred to in the trace; this flag
    overrides that behavior, causing `artc` to include all entries in
    *INITFILE* unconditionally.


-d *PARSERS*, \--debug=*PARSERS*

  : Enable bison's built-in debugging for a comma-separated list
    (*PARSERS*) of any of the various parsers employed by `artc`:
    *trace*, *initlist*, and *iostat*.


-h, \--help

  : Print a usage summary to stdout and exit successfully.


-I, \--ibench

  : Parse the provided *TRACEFILE* as an iBench-style trace.


-S, \--strace

  : Parse the provided *TRACEFILE* as an `strace`(1) trace (this is
    the default).


-i *IOSTAT*, \--iostat=*IOSTAT*

  : In addition to *TRACEFILE* and *INITFILE*, also parse *IOSTAT* to
    extract CPU utilization information (this can be incorporated in
    `artrun`'s predelay calculations).  *IOSTAT* should be in the
    format generated by `iostat`(1), which is assumed to have been run
    with a 1-second report interval.

    Note: this option is somewhat experimental and not guaranteed to
    be well-supported if, for example, your version of `iostat`(1) has
    a slightly different output format than `artc` expects.

-t, \--intra-thread

  : Include intra-thread dependencies in `artc`'s output.  By default,
    `artc` elides dependencies between events in the same thread,
    since they will be enforced implicitly by `artrun` regardless of
    their presence or absence; this option causes `artc` to include
    them anyway.

# SEE ALSO

`artrun`(1), `strace-artc.sh`(1), `geninit.sh`(1), `iostat`(1), `gperf`(1)
