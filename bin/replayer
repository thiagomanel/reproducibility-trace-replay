#!/bin/bash

source $HOME_REPLAYER/etc/environment.conf
source $HOME_REPLAYER/lib/helpers.sh

nsamples=$N_SAMPLES
nrepetitions=10

artc_geninit() {
	echo "--> generating init files..."
	local used_dirs="$TARGET_MNT"

	if [ ! -x $ARTC_GENINIT ]; then
		echo "You need to compile artc code for geninit, of maybe you did not set HOME_REPLAYER variable"
		exit 1;
	fi

	mkdir -p $ARTC_GENINIT_OUTDIR
	$ARTC_GENINIT -a $used_dirs > $ARTC_GENINIT_FILE
	echo "<-- finished generating init files"
}

compile_artc_trace() {
	make --directory=$1 --makefile=$1/Makefile 1> $1/log.out 2> $1/log.err
	success_or_die;
}

exec_artc_codegen() {
	mkdir -p $ARTC_GEN_OUTDIR
	success_or_die;

	local counter=0;

	for trace_file in $CONVERTED_OUTDIR_ARTC/*.*.*.*.*.*.load.out; do
		echo -n "  generating code for($((++counter))): $trace_file -> "
		local artc_gen_outdir=$ARTC_GEN_OUTDIR/$(basename $trace_file)
		mkdir -p $artc_gen_outdir
		success_or_die;

		$ARTC_CODEGEN --strace $trace_file $ARTC_GENINIT_FILE $artc_gen_outdir
		echo_status $?;

		echo -n "  compiling code for($counter): $trace_file -> "
		compile_artc_trace $artc_gen_outdir
		echo_status $?;
	done
}

artc_codegen() {
	echo "--> compiling traces for artc..."

	if [ ! -x $ARTC_GENINIT ]; then
		echo "You need to compile artc code for geninit, of maybe you did not set HOME_REPLAYER variable"
		exit 1;
	fi

	if [ ! -f $ARTC_GENINIT_FILE ]; then
		echo "You need to generate init file first, try --artc-geninit"
		exit 1;
	fi

	exec_artc_codegen;
	echo "<-- finished compiling traces for artc"
}

artcrun_root() {
	$ARTC_RUN --predelay-multiplier=0 $trace_dir/bench.so $TARGET_MNT
}

artcrun_temporal() {
	$ARTC_RUN --predelay-multiplier=0 --disable-constraints=all --enable-constraints=temporal $trace_dir/bench.so $TARGET_MNT
}

run_artc_policy() {
	case $policy in
		root)
			artcrun_root;
			success_or_die;
			;;
		temporal)
			artcrun_temporal;
			success_or_die;
			;;
		*)
			echo "Buddy, you need to specify a valid artc policy!"
			exit 1;
	esac
}

do_sleep() {
	if [ $sleeping ]; then
		sleep $sleep_sec
	fi
}

run_artc() {
	echo "--> executing artcrun ($policy policy)"

	local output_dir="$ARTC_BASE_RESULTS_OUTDIR-$policy"
	mkdir -p $output_dir
	success_or_die

	local total_executions=$(calculate_total_executions)
	local counter=0;

	for capture_sample in `seq 1 $nsamples`; do
		for trace_dir in $ARTC_GEN_OUTDIR/$capture_sample.*.*.*.*.*.*.*.*.load.out; do
			for sample in `seq 1 $nrepetitions`; do
				local output_file_base=$ARTC_REPLAYER_OUTDIR_TEMPORAL/$(basename $trace_dir).$sample.$policy

				echo -n "  --> executing[$policy]($((++counter))/$total_executions): $trace_dir/bench.so --> $output_file_base -> "
				run_artc_policy 1> $output_file_base.out 2> $output_file_base.err;
				echo_status $?;

				do_sleep;
			done
		done
	done

	echo "<-- finished execution artcrun ($policy policy)"
}

run_beefs_policy() {
	for sample in `seq -w 01 $nrepetitions`; do
		local output_file_base=$output_dir/$(basename $1).$sample.$beefs_policy
		echo -n "."

		$LIB_HOME/clearcache.sh $TARGET_MNT 1> $output_file_base.clearcache.out 2> $output_file_base.clearcache.err;
		success_or_die;

		$BEEFS_REPLAYER $1 $2 $3 0 debug 1> $output_file_base.out 2> $output_file_base.err;
		success_or_die;

		do_sleep;
		success_or_die;
	done
}

calculate_total_executions() {
	local total_executions=0
	for sample in `seq -w 01 $nsamples`; do
		local counter=$(ls -l $1/$sample.*.*.*.*.*.*.*.*.load.out | wc -l);
		local total_executions=$(( $total_executions + $counter * $nrepetitions ))
	done
	echo $total_executions
}

run_beefs() {
	echo "--> executing beefs ($beefs_policy policy)"
	output_dir="$REPLAYER_OUTDIR-$beefs_policy"

	mkdir -p $output_dir
	success_or_die;

	local total_executions=$(calculate_total_executions $CONVERTED_OUTDIR);
	local counter=0;

	for capture_sample in `seq -w 01 $nsamples`; do
		for nthreads in $N_THREAD; do
			for trace_file in $CONVERTED_OUTDIR/$capture_sample.*.*.$nthreads.*.*.*.*.*.load.out; do
				echo -n "  --> executing[$beefs_policy]($counter)/$total_executions): $trace_file "
				local counter=$(( counter + $nrepetitions ))
				run_beefs_policy $trace_file $beefs_policy $nthreads;
				echo_status $?;
			done
		done
	done

	echo "<-- finished execution beefs ($beefs_policy policy)"
}

check_artc_parameters() {
	if [[ ! $geninit && ! $codegen && ! $artcrun ]]; then
		echo "Dude, you must define an action to artc!"
		exit 1;
	fi

	if [ $artcrun ]; then
		case $policy in
			root)
				;;
			temporal)
				;;
			*)
				echo "Buddy, you need to specify a valid artc policy!"
				exit 1;
				;;
		esac
	fi
}

check_beefs_parameters() {
	case $beefs_policy in
		faster | conservative)
			;;
		*)
			echo "Buddy, you need to specify a valid beefs policy!"
			exit 1;
			;;
	esac
}

check_parameters() {
	check_parameter $replayer "-r | --replayer is missing"

	case $replayer in
		beefs)
			check_beefs_parameters;
			success_or_die;
			;;
		artc)
			check_artc_parameters;
			success_or_die;
			;;
		*)
			echo "Man, you must define a valid replayer!"
			exit 1;
			;;
	esac

	if [[ $sleeping && ! $sleep_sec =~ ^[0-9]+$ ]]; then
		echo "Guy, sleeping is given in seconds."
		exit 1;
	fi


	if [[ ! $nsamples =~ ^[0-9]+$ ]]; then
		echo_fail "Guy, you gave an invalid number of samples, please try --help."
		exit 1;
	fi
}

show_help() {
	echo "Usage: $0 --replayer [beefs | artc] (MANDATORY) --artc-geninit (OPTIONAL) --artc-codegen (OPTIONAL) --artc-run [root | temporal] (OPTIONAL) --sleep N (OPTIONAL) | --help"
	echo "Usage: $0 --replayer beefs --beefs-policy [conservative | faster]"
	echo "Usage: $0 --replayer artc --artc-geninit (OPTIONAL) --artc-codegen (OPTIONAL) --artc-run [root | temporal] (OPTIONAL) --sleep N (OPTIONAL)p"
	echo
	echo "-r | --replayer: the type of replayer to use, artc or beefs. Note that if using artc, you need to specify at least one action (-g, -c or -x)"
	echo "                 note that you can use more than one action at time, if using artc. The actions will be executed in right order."
	echo "-g | --artc-geninit: generates init file for artc (step 1 when running artc)"
	echo "-c | --artc-codegen: generates code from converted traces + init files (step 2 when running artc)"
	echo "-x | --artc-run: executes the compiled trace with artc following the specified policy. the policycan be root or temporal (step 3 when running artc)"
	echo "-s | --sleep: sleeps N seconds in end of each execution."
	echo "-n | --samples: number of captured samples (repetitions) to run, default is extracted from etc/environment.conf (default in file is 10)"
}

# define and check all necessary parameters from the given arguments.
# the check is verifies all dependencies
define_parameters() {
	while [ ! -z $1 ]; do
		case $1 in
			-r | --replayer)
				shift;
				replayer=$1;
				;;
			-g | --artc-geninit)
				geninit=true;
				;;
			-c | --artc-codegen)
				codegen=true;
				;;
			-x | --artc-run)
				shift;
				artcrun=true;
				policy=$1;
				;;
			-s | --sleep)
				shift;
				sleeping=true;
				sleep_sec=$1
				;;
			-p | --beefs-policy)
				shift;
				beefs_policy=$1;
				;;
			-n | --samples)
				shift;
				nsamples=$1;
				;;
			-h | --help)
				show_help;
				exit 0;
				;;
			*)
				echo "Please, try --help to see the list of available parameters"
				exit 1;
				;;
		esac
		shift
	done

	check_parameters;
	success_or_die;
}

exec_beefs() {
	run_beefs
}


# executes all steps for artc, if given the arguments,
# in the right order (gen init, code gen and then artrun).
# a step will be executed, only if it was explicited as an argument.
exec_artc() {
	if [ $geninit ]; then
		artc_geninit;
	fi

	if [ $codegen ]; then
		artc_codegen;
	fi

	if [ $artcrun ]; then
		run_artc;
	fi
}

execute() {
	case $replayer in
		beefs)
			exec_beefs;
			;;
		artc)
			exec_artc;
			;;
		*)
			echo "Man, you must define a valid replayer!"
			exit 1;
			;;
	esac
}



main() {
	define_parameters $@;
	success_or_die;

	execute;
	success_or_die;
}

main $@;
